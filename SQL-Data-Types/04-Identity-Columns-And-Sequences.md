# Identity columns and sequences

## Welcome

Hello and welcome to the third part of our **Understanding Data Types** course. This time we're going to take a break from introducing new data types. Instead, we'll show you how to make your database generate identity columns automatically.

Did you get enough rest after the previous part? Let's get started, then!

## GENERATED ALWAYS AS IDENTITY

Good. Let's now talk about single-column primary keys with integer numbers. They are the most frequent choice in professional databases. Because of their popularity, database system creators have decided to make our lives easier: They've provided us with tools to automatically number our rows! Take a look:

```sql
CREATE TABLE movie (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  title varchar(64),
  year int,
  genre varchar(20)
);
```

As you can see, we've added the following keywords after the type of the first column: `GENERATED ALWAYS AS IDENTITY`. Thanks to this, the database will know that it should calculate consecutive numbers for this column on its own.

Note that you can have the database generate values automatically even in non-primary keys.

### Exercise

Let's try to add a new row to the table `movie`. Run the template code. What do you think will happen?

Success! Look at the table – the value for the column `id` has been generated automatically. The database took care of the numbering. Isn't that great?

```sql
INSERT INTO movie (title, year, genre)
VALUES ('Birdman', 2014, 'comedy-drama');
```

Output:

```
(1 row(s) affected)
 id |  title  | year | genre
----+---------+------+-------
  1 | Birdman |  2014 | comedy-drama
```

## GENERATED ALWAYS AS IDENTITY – insert rows

Good job! You can see that `GENERATED ALWAYS AS IDENTITY` added after a column type auto-generates integers for you.

### Exercise

Add a few more rows to the table and see for yourself how the consecutive numbers are generated for the column `id`. As you can see, new values are generated automatically.

```sql
INSERT INTO movie (title, year, genre)
VALUES ('The Dark Knight', 2008, 'action'),
       ('The Dark Knight Rises', 2012, 'action'),
       ('Inception', 2010, 'action');
```

## GENERATED ALWAYS AS IDENTITY – insert rows with identity

Perfect. The code worked like a charm! However, you should also remember that using `GENERATED ALWAYS AS IDENTITY` doesn't allow you to provide any specific values on your own. Just as the syntax suggests, the values are `GENERATED ALWAYS`, with no exception. Let's check that.

### Exercise

Now, try to add a row with your own value for the `id` column. This statement will fail. When you use `GENERATED ALWAYS AS IDENTITY`, you can never provide your own values for the given column.

```sql
INSERT INTO movie (id, title, year, genre) 
VALUES (2, 'Shrek', 2001, 'comedy');
```

Output:

```
ERROR: cannot insert into column "id" Detail: Column "id" is an identity column defined as GENERATED ALWAYS. Hint: Use OVERRIDING SYSTEM VALUE to override. Line: 1 Position in the line: 1
```

## GENERATED ALWAYS AS IDENTITY – exercise

Good job! It's your turn to create a table with `GENERATED ALWAYS AS IDENTITY`.

### Exercise

We need a table to keep track of movie reviews. Create a table named review with the following columns:

1. `id` – Contains auto-generated integer values (`GENERATED ALWAYS AS IDENTITY`) and is the **primary key** for this table.
2. `author_id` – An `integer` column.
3. `title` – A column with up to 64 characters.
4. `rating` – An `integer` column.

```sql
CREATE TABLE review (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    author_id INTEGER,
    title VARCHAR(64),
    rating INTEGER
);
```

## GENERATED BY DEFAULT AS IDENTITY

As we previously stated, `GENERATED ALWAYS AS IDENTITY` makes it impossible to insert our own values into a given column. Luckily, we can change that. Take a look:

```sql
CREATE TABLE movie (
  id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title varchar(64),
  year int,
  genre varchar(20)
);
```

This time, instead of `ALWAYS` we wrote `BY DEFAULT`. As a result, the database will only generate consecutive numbers when we don't provide a specific value ourselves. Let's check that.

### Exercise

Try to add a new row to the `movie` table. It's a movie called `Dancing Tonight` from `2018` and the genre is `musical`. Do NOT specify the `id` column.

Will the `id` be auto-generated?

```sql
INSERT INTO movie (title, year, genre)
VALUES ('Dancing Tonight', 2018, 'musical');
```

Output:

```
(1 row(s) affected)
 id |    title    | year | genre
----+-------------+------+-------
  1 | Birdman |  2014 | comedy-drama
  2 | Dancing Tonight |  2018 | musical
```

## GENERATED BY DEFAULT AS IDENTITY – insert rows

Great! The `id` column was auto-generated. Now, let's try to specify our own value.

### Exercise

Try to add another row to the table movie. The movie is called `Feather`, was released in `2012`, and is a `thriller`. Provide your own `id` value of `100`. What will happen?

As you can see, the database accepted your value for the `id` column.

```sql
INSERT INTO movie (id, title, year, genre)
VALUES (100, 'Feather', 2012, 'thriller');
```

Output:

```
(1 row(s) affected)
 id |    title    | year | genre
----+-------------+------+-------
  1 | Birdman |  2014 | comedy-drama
  2 | Dancing Tonight |  2018 | musical
 100 | Feather |  2012 | thriller
```

## GENERATED BY DEFAULT AS IDENTITY – create your own

Good. Everything works well. Now it's your turn to create a table with `GENERATED BY DEFAULT AS IDENTITY`. Remember to put that information after the column type!

### Exercise

Create a table called `theater` with the following columns:

1. `theater_id` – The **primary key**, an `integer` column with consecutive numbers automatically generated (`GENERATED BY DEFAULT AS IDENTITY`).
2. `name` – Up to 30 characters.
3. `city` – Up to 30 characters.

Important: You should also be able to provide your own values for the `theater_id` column.

```sql
CREATE TABLE theater (
    theater_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(30),
    city VARCHAR(30)
);
```

## IDENTITY with starting values and increment size

Excellent. There is actually one more thing about `GENERATED ... AS IDENTITY` that you need to know. You can change its behavior! You do not need to start counting from 1, nor do you need to add 1 to every new value. Take a look:

```sql
CREATE TABLE movie (
  id integer GENERATED ALWAYS AS IDENTITY (START WITH 5 INCREMENT BY 10) PRIMARY KEY,
  title varchar(64),
  year int,
  genre varchar(20)
);
```

After the keyword `IDENTITY`, we put two values in the parentheses. The first one (`START WITH`) tells the database about the starting point value. In this case, the first row will get the number 5. The second value (`INCREMENT BY`) informs the database how it should calculate further values. In this case, we're asking it to add 10 each time. So, after 5, we'll have 15, 25, 35...

### Exercise

We've created a table named `theater` for you using the following code:

```sql
CREATE TABLE theater (
  theater_id integer GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 2) PRIMARY KEY,
  name varchar(30),
  city varchar(30)
);
```

As you can see, only odd-numbered identifiers should be generated. Your task is to insert some rows and observe if that's true.

1. Add a theater named **Paramount** in the city of **Seattle**. What ID has been generated for this row?
2. Add a theater named **Moore** in the same city (**Seattle**). What ID can you see for this row?

```sql
INSERT INTO theater (name, city)
VALUES ('Paramount', 'Seattle'),
       ('Moore', 'Seattle');
```

Output:

```
(2 row(s) affected)
 theater_id |    name    |   city
------------+------------+------------
          1 | Paramount | Seattle
          3 | Moore     | Seattle
```

## IDENTITY with starting values and increment size – exercise

Good! As you saw, we only had odd numbers as IDs in the `cinema` table.

It's time for you to create your own table with a custom `id` column.

### Exercise

Our theaters want to introduce a subscription model with a monthly fee and an unlimited number of tickets. Create the table `subscription` with the following columns:

1. `id` – An integer and the primary key. The value starts at 10 and increases by 10 (i.e., 10, 20, 30...) and should be `GENERATED ALWAYS`.
2. `user_id` – An integer.
3. `start_date` – A date (data type date).
4. `duration_days` – An integer.

```sql
CREATE TABLE subscription (
    id INTEGER GENERATED ALWAYS AS IDENTITY (START WITH 10 INCREMENT BY 10) PRIMARY KEY,
    user_id INTEGER,
    start_date DATE,
    duration_days INTEGER
);
```

## Creating sequences

Okay, great! We now know how to auto-generate integer columns with `GENERATED ... AS IDENTITY`. **However, another similar mechanism is also available in most databases**. The mechanism is known as a **sequence object**. As the name suggests, sequence objects automatically generate new numbers in a sequence. Have a look:

```sql
CREATE SEQUENCE first_seq
START WITH 1 INCREMENT BY 1;
```

You've probably guessed what this code does. It will create a sequence named `first_seq`, with the initial value of 1, that will be increased by 1 each time.

Note that a sequence can be created in a database independently of any table.

### Exercise

Create a sequence named `my_sequence`, which starts from `100` and increases by `10`.

```sql
CREATE SEQUENCE my_sequence
START WITH 100 INCREMENT BY 10;
```

## Getting values from sequences

Good. Once we create a sequence, we can use a special instruction to retrieve its next value. The code varies depending on the database. The standard syntax is:

```sql
SELECT NEXT VALUE FOR first_seq;
```

Unfortunately, the syntax above doesn't work in PostgreSQL, which is our database engine. We'll have to use another syntax:

```sql
SELECT nextval('first_seq');
```

The above code will select the next value for the sequence named `first_seq`.

### Exercise

Select the next value for your new sequence `my_sequence`.

```sql
SELECT nextval('my_sequence');
```

## Inserting rows with values from sequences

Good! Now let's put everything together. Suppose we have the following table:

```sql
CREATE TABLE movie (
  id integer PRIMARY KEY,
  title varchar(64),
  year int,
  genre varchar(20)
);
```

Note that the column `id` is NOT auto-generated here. We've also got our `first_seq` sequence object. Now, whenever we insert a new row, we can retrieve a number from the sequence:

```sql
INSERT INTO movie (id, title, year, genre) VALUES (nextval('first_seq'), 'Kill Me', 1992, 'thriller');
```

As you can see, instead of providing an explicit value for the column `id`, we used `nextval('first_seq')`.

### Exercise

We've created a table named `director` with two columns: `id` (`integer`) and `full_name` (`varchar`). We've also created a sequence named `director_seq`. Your task is to insert two directors into the table: **Adam Smith** and **Kate Adams**. Both of them should take their `id` column value from the sequence.

```sql
INSERT INTO director (id, full_name) 
VALUES (nextval('director_seq'), 'Adam Smith'),
        (nextval('director_seq'), 'Kate Adams');
```

## Summary

It's time to wrap things up for this part! First, let's review:

1. If you want to generate values for an `integer` column automatically and you never want to insert your own values, use:

```sql
column_name integer GENERATED ALWAYS AS IDENTITY
```

2. If you want to generate values for an `integer` column automatically but you will also sometimes insert your own values, use:

```sql
column_name integer GENERATED BY DEFAULT AS IDENTITY
```

3. To start generating from 5 and increment the counter by 10 each time, use:

```sql
column_name integer GENERATED ALWAYS AS IDENTITY (START WITH 5 INCREMENT BY 10)
```

4. To create a sequence, use:

```sql
CREATE SEQUENCE first_seq START WITH 1 INCREMENT BY 1;
```

5. To retrieve the next value from a sequence in PostgreSQL, use:

```sql
nextval('first_seq')
```

All right, how about a short quiz?

### Exercise 1

A zoo in Ohio needs a table to keep track of their animals. Create a table named `animal` with the following columns:

1. `id` – The primary key, it's an `integer` value that's always generated automatically. Start with the value of 2 and only generate even numbers.
2. `name` – Up to 32 characters.
3. `type` – Up to 32 characters.
4. `year_born` – An `integer` value.

```sql
CREATE TABLE animal (
    id INTEGER GENERATED ALWAYS AS IDENTITY (START WITH 2 INCREMENT BY 2) PRIMARY KEY,
    name VARCHAR(32),
    type VARCHAR(32),
    year_born INTEGER
);
```

### Exercise 2

The Ohio zoo also needs to keep track of animal caretakers.

1. Create a table named `animal_caretaker` with two columns: `id` (`integer`, primary key) and `full_name` (up to 32 characters).
2. Create a sequence named `caretaker_seq`. Start with the value of `1` and increment by `2`.
3. Insert a new caretaker named **Alexander Owens**. Use the sequence to generate the value for the `id` column.

```sql
CREATE TABLE animal_caretaker (
    id INTEGER PRIMARY KEY,
    full_name VARCHAR(32)
);

CREATE SEQUENCE caretaker_seq START WITH 1 INCREMENT BY 2;

INSERT INTO animal_caretaker (id, full_name)
VALUES (nextval('caretaker_seq'), 'Alexander Owens');
```

## Congratulations

Perfect! That was the last exercise in this part of the course, and you got it. Congratulations!

In the next part, we'll focus on `boolean`, `date` and `timestamp` columns. See you there!
